################################################################################
# Probabilistic sensitivity analysis. This does processPersons many times.
## ADAPTED BY MJS 07/03/17 TO WORK WITH processPersonsAboveDiagnosticThreshold



# The usual output of a PSA is "v0$numberOfParameterIterations" different 
# numbers for all the quantities. This will be returned as a three-dimensional 
# array. 
# 
# v2values, if it is supplied, must be a list of v0$numberOfParameterIterations
# lists, each of which can be used as a specific value of v2 (i.e. a specific 
# set of global uncertain parameters). 
# The normal way of using psa is to NOT supply v2values. If v2values is 
# supplied, then it must presumably have been pre-generated, outside psa,  
# probably using generateV2.
# 
# If v0$numberOfParameterIterations is 1 then this will not strictly speaking 
# be a PSA but it will generate the uncertain global variables randomly 
# (assuming v2values is not given).

psaAboveDiagnosisThreshold <- function(v0, v1other, v1distributions, v2values,threshold=3.0) {
	
	# Set some elements of v0 as needed for PSA. 
	v0 <- setUnspecifiedElementsOfv0(v0)  # several of these will be changed ...
	v0$returnMeanQuantities <- TRUE
	v0$returnAllPersonsQuantities <- FALSE
	v0$showEventHistories <- FALSE
	v0$verbose <- FALSE  # prevent processPersons from being verbose
	# TODO: print a message if these elements of v0 were set inappropriately 
	
	# Check the arguments.
	checkArgs(v0=v0, v1other=v1other, v1distributions=v1distributions)
	
	# Display messages, settings, parameters, etc.
	cat("Running psa on ", Sys.info()["nodename"], " with:\n  ", 
			"v0$numberOfParameterIterations=", v0$numberOfParameterIterations, 
			", v0$numberOfPersons=", v0$numberOfPersons, 
			", numberOfProcesses=", v0$numberOfProcesses, "\n", sep="")
	cat("\n########## v0 ##########\n")
	print(v0)
	cat("########## v1other ##########\n")
	print(v1other)
	cat("########## v1distributions ##########\n")
	print(v1distributions)
	cat("########################\n\n")
	if (v0$returnEventHistories)  # this should only be used with caution!
		cat("In psa, v0$returnEventHistories is TRUE, so this will take a ",
				"lot of memory.\n", sep="")
	# previously: v0$returnEventHistories <- FALSE
	if ("generateCensoringTime" %in% names(v0))
		cat("Censoring is being used, so life-years etc. will be calculated",
				"up to censoring times.\n")
	
	# If v2values is missing (as it usually is), then create it. 
	# If it is given, then check it.
	if (missing(v2values)) {  
		# previously: v2values <- NULL, and onePsaIteration generated v2values
		setAndShowRandomSeed(v0$randomSeed, verbose=TRUE)  # uses set.seed
		v2values <- replicate(n=v0$numberOfParameterIterations, 
				expr=generateV2(v1distributions), simplify=FALSE) 
	} else {
		npi <- v0$numberOfParameterIterations
		if (!is.list(v2values) || !all(sapply(v2values, is.list)) ||
				length(v2values) !=	npi)
			stop("if v2values is given then it must be a list of length\n",
					"  v0$numberOfParameterIterations=", npi,
					" whose elements are all lists that are values of v2")
		cat("NB v2values has been supplied to psa, so v2 has not been ",
				"generated by psa.\n", sep="")
	}
	
	# Main PSA loop. NB this changes v0$randomSeed and sometimes also v0$method.
	# (Set the random seed again here, for safety; for "parallel" this is 
	# essential, as it needs to be done using clusterSetRNGStream.) 
	if (v0$method == "serial") {
		setAndShowRandomSeed(v0$randomSeed, verbose=TRUE)
		v0$randomSeed <- NULL  # so that processPersons will not set the seed
		resultOfApply <- lapply(X=1:v0$numberOfParameterIterations, 
				FUN=onePsaIterationAboveDiagnosisThreshold, v0, v1other, v2values, threshold)
	} else if (v0$method == "parallel") {
		# Do PSA in parallel and processPersons serially. (This is important 
		# both for sensible parallelization and for reproducibility with the 
		# random numbers and clusterSetRNGStream etc.)
		v0$method <- "serial"  # so that processPersons is serial
		require(parallel, quietly=TRUE)
		cluster <- makeCluster(v0$numberOfProcesses)  # , outfile="")
		clusterExport(cluster, getAllFunctionsAndStringsInGlobalEnv())
		setAndShowRandomSeed(randomSeed=v0$randomSeed, cluster=cluster, 
				verbose=TRUE)  # the order of these lines is important!
		v0$randomSeed <- NULL  # so that processPersons does not set the seed
		resultOfApply <- parLapply(cl=cluster, 
				X=1:v0$numberOfParameterIterations, fun=onePsaIterationAboveDiagnosisThreshold, v0, 
				v1other, v2values, threshold)
		stopCluster(cluster) 
	} else if (v0$method == "foreach" || v0$method == "parallelBatches") {
		stop("v0$method=", v0$method, " has not been implemented for psa")
	} else {
		stop("v0$method=", v0$method, " is illegal")
	}


	# Put the incremental mean quantities into a 2D array and the v2 values (from 
	# resultOfApply) into a list.
	psaQuantities <- makeArray(
  		psaIterationNumber=1:v0$numberOfParameterIterations
  		,	quantity=v0$namesOfQuantities)
	v2valuesFromResultOfApply <- 
			vector(mode="list", length=v0$numberOfParameterIterations)
	for (i in 1:v0$numberOfParameterIterations) {
		psaQuantities[i,] <- resultOfApply[[i]]$incrementalMeanQuantities
		v2valuesFromResultOfApply[[i]] <- resultOfApply[[i]]$v2
	}
	# Check that v2values = v2valuesFromResultOfApply: (maybe unnecessary now 
	# that v2values is usually created in psa itself; but keep this for safety)
	if (!identical(v2values, v2valuesFromResultOfApply))
		stop("INTERNAL ERROR: v2values as supplied to psa should be the ",
				"same as v2valuesFromResultOfApply")
	
	# Calculate ICERs and INMBs
	## CI for the ICER should be calculated based on the proportion of points below the willingness to pay threshold
	## So a negative ICER caused by incremental effect<0 and incremental cost>0 will by definition be assigned Infinity
	ICER_lifeYears<-psaQuantities[,"cost"]/psaQuantities[,"lifeYears"]
	ICER_lifeYears[psaQuantities[,"lifeYears"]<0 & psaQuantities[,"cost"]>0]<-Inf
	ICER_discountedLifeYears<-psaQuantities[,"discountedCost"]/psaQuantities[,"discountedLifeYears"]
	ICER_discountedLifeYears[psaQuantities[,"discountedLifeYears"]<0 & psaQuantities[,"discountedCost"]>0]<-Inf
	ICER_discountedQalys<-psaQuantities[,"discountedCost"]/psaQuantities[,"discountedQalys"]
	ICER_discountedQalys[psaQuantities[,"discountedQalys"]<0 & psaQuantities[,"discountedCost"]>0]<-Inf
	psaQuantities<-cbind(psaQuantities,ICER_lifeYears,ICER_discountedLifeYears,ICER_discountedQalys)
	
	INMB_discountedQalys_20000<- (psaQuantities[,"discountedQalys"]*20000 - psaQuantities[,"discountedCost"])
	INMB_discountedQalys_30000<- (psaQuantities[,"discountedQalys"]*30000 - psaQuantities[,"discountedCost"])
	psaQuantities<-cbind(psaQuantities,INMB_discountedQalys_20000,INMB_discountedQalys_30000)
	                     
	# Return psaQuantities and v2values
	result <- list(psaQuantities=psaQuantities, v2values=v2values)
	cat("psa is about to return an object of size ", 
			format(object.size(result), unit="auto"), ".\n", sep="")
	return(result)
}


################################################################################
# A function that will be called by psa v0$numberOfParameterIterations times, 
# using parLapply. 

onePsaIterationAboveDiagnosisThreshold <- function(psaIterationNumber, v0, v1other, 
		v2values,threshold) {
	# Get v2, the values of the uncertain global variables, and check it.
	if (is.null(v2values)) 
	    stop("INTERNAL ERROR: v2values should be generated in psa ",
				"or passed into psa by the user")
    v2 <- v2values[[psaIterationNumber]]
    if (is.null(v2)) stop("v2values[[", psaIterationNumber, "]] is NULL")
	if (!is.list(v2)) stop("v2values[[", psaIterationNumber,"]] must be a list")
	if (!("probOfNonvisualization" %in% names(v2)))
		stop("v2 must contain probOfNonvisualization (and many other elements)")
	
	# Create and analyze the persons, and return what is needed.
	processPersonsResult <- processPersonsAboveDiagnosisThreshold(v0, v1other, v2,threshold)
	result <- list(incrementalMeanQuantities=processPersonsResult$incrementalMeanQuantities, v2=v2)

	return(result)
}



