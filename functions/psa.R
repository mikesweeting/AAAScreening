################################################################################
# Probabilistic sensitivity analysis. This does processPersons many times.

# The usual output of a PSA is "v0$numberOfParameterIterations" different 
# numbers for all the quantities. This will be returned as a three-dimensional 
# array. 
# 
# v2values, if it is supplied, must be a list of v0$numberOfParameterIterations
# lists, each of which can be used as a specific value of v2 (i.e. a specific 
# set of global uncertain parameters). 
# The normal way of using psa is to NOT supply v2values. If v2values is 
# supplied, then it must presumably have been pre-generated, outside psa,  
# probably using generateV2.
# 
# If v0$numberOfParameterIterations is 1 then this will not strictly speaking 
# be a PSA but it will generate the uncertain global variables randomly 
# (assuming v2values is not given).

psa <- function(v0, v1other, v1distributions, v2values) {
	
	# Set some elements of v0 as needed for PSA. 
	v0 <- setUnspecifiedElementsOfv0(v0)  # several of these will be changed ...
	v0$returnMeanQuantities <- TRUE
	v0$returnAllPersonsQuantities <- FALSE
	v0$showEventHistories <- FALSE
	v0$verbose <- FALSE  # prevent processPersons from being verbose
	# TODO: print a message if these elements of v0 were set inappropriately 
	
	# Check the arguments.
	checkArgs(v0=v0, v1other=v1other, v1distributions=v1distributions)
	
	# Display messages, settings, parameters, etc.
	cat("Running psa on ", Sys.info()["nodename"], " with:\n  ", 
			"v0$numberOfParameterIterations=", v0$numberOfParameterIterations, 
			", v0$numberOfPersons=", v0$numberOfPersons, 
			", numberOfProcesses=", v0$numberOfProcesses, "\n", sep="")
	cat("\n########## v0 ##########\n")
	print(v0)
	cat("########## v1other ##########\n")
	print(v1other)
	cat("########## v1distributions ##########\n")
	print(v1distributions)
	cat("########################\n\n")
	if (v0$returnEventHistories)  # this should only be used with caution!
		cat("In psa, v0$returnEventHistories is TRUE, so this will take a ",
				"lot of memory.\n", sep="")
	# previously: v0$returnEventHistories <- FALSE
	if ("generateCensoringTime" %in% names(v0))
		cat("Censoring is being used, so life-years etc. will be calculated",
				"up to censoring times.\n")
	
	# If v2values is missing (as it usually is), then create it. 
	# If it is given, then check it.
	if (missing(v2values)) {  
		# previously: v2values <- NULL, and onePsaIteration generated v2values
		setAndShowRandomSeed(v0$randomSeed, verbose=TRUE)  # uses set.seed
		v2values <- replicate(n=v0$numberOfParameterIterations, 
				expr=generateV2(v1distributions), simplify=FALSE) 
	} else {
		npi <- v0$numberOfParameterIterations
		if (!is.list(v2values) || !all(sapply(v2values, is.list)) ||
				length(v2values) !=	npi)
			stop("if v2values is given then it must be a list of length\n",
					"  v0$numberOfParameterIterations=", npi,
					" whose elements are all lists that are values of v2")
		cat("NB v2values has been supplied to psa, so v2 has not been ",
				"generated by psa.\n", sep="")
	}
	
	# Main PSA loop. NB this changes v0$randomSeed and sometimes also v0$method.
	# (Set the random seed again here, for safety; for "parallel" this is 
	# essential, as it needs to be done using clusterSetRNGStream.) 
	if (v0$method == "serial") {
		setAndShowRandomSeed(v0$randomSeed, verbose=TRUE)
		v0$randomSeed <- NULL  # so that processPersons will not set the seed
		resultOfApply <- lapply(X=1:v0$numberOfParameterIterations, 
				FUN=onePsaIteration, v0, v1other, v2values)
	} else if (v0$method == "parallel") {
		# Do PSA in parallel and processPersons serially. (This is important 
		# both for sensible parallelization and for reproducibility with the 
		# random numbers and clusterSetRNGStream etc.)
	  v0$method <- "serial"  # so that processPersons is serial
		require(parallel, quietly=TRUE)
		cluster <- makeCluster(v0$numberOfProcesses)  # , outfile="")
		clusterExport(cluster, getAllFunctionsAndStringsInGlobalEnv())
		setAndShowRandomSeed(randomSeed=v0$randomSeed, cluster=cluster, 
				verbose=TRUE)  # the order of these lines is important!
		v0$randomSeed <- NULL  # so that processPersons does not set the seed
		resultOfApply <- parLapply(cl=cluster, 
				X=1:v0$numberOfParameterIterations, fun=onePsaIteration, v0, 
				v1other, v2values)
		stopCluster(cluster) 
	} else if (v0$method == "foreach" || v0$method == "parallelBatches") {
		stop("v0$method=", v0$method, " has not been implemented for psa")
	} else {
		stop("v0$method=", v0$method, " is illegal")
	}
	
	# Put the mean quantities into a 3D array and the v2 values (from 
	# resultOfApply) into a list.
	psaQuantities <- makeArray(
			treatmentGroup=v0$treatmentGroups, 
			quantity=v0$namesOfQuantities,
			psaIterationNumber=1:v0$numberOfParameterIterations)
	v2valuesFromResultOfApply <- 
			vector(mode="list", length=v0$numberOfParameterIterations)
	for (i in 1:v0$numberOfParameterIterations) {
		psaQuantities[,,i] <- resultOfApply[[i]]$meanQuantities
		v2valuesFromResultOfApply[[i]] <- resultOfApply[[i]]$v2
	}
	# Check that v2values = v2valuesFromResultOfApply: (maybe unnecessary now 
	# that v2values is usually created in psa itself; but keep this for safety)
	if (!identical(v2values, v2valuesFromResultOfApply))
		stop("INTERNAL ERROR: v2values as supplied to psa should be the ",
				"same as v2valuesFromResultOfApply")
	
	# If v0$returnEventHistories, then put the event-histories into a list. 
	if (v0$returnEventHistories) {
		eventHistoryLists <- 
				vector(mode="list", length=v0$numberOfParameterIterations)
		for (i in 1:v0$numberOfParameterIterations)
			eventHistoryLists[[i]] <- resultOfApply[[i]]$eventHistories
	}
	
	# Return psaQuantities and v2values, and if v0$returnEventHistories then 
	# also include eventHistoryLists.
	result <- list(psaQuantities=psaQuantities, v2values=v2values)
	if (v0$returnEventHistories) result$eventHistoryLists <- eventHistoryLists
	cat("psa is about to return an object of size ", 
			format(object.size(result), unit="auto"), ".\n", sep="")
	return(result)
}

################################################################################
# A function that will be called by psa v0$numberOfParameterIterations times, 
# using parLapply. 

onePsaIteration <- function(psaIterationNumber, v0, v1other, 
		v2values) {
	# Get v2, the values of the uncertain global variables, and check it.
	if (is.null(v2values)) 
	    stop("INTERNAL ERROR: v2values should be generated in psa ",
				"or passed into psa by the user")
    v2 <- v2values[[psaIterationNumber]]
    if (is.null(v2)) stop("v2values[[", psaIterationNumber, "]] is NULL")
	if (!is.list(v2)) stop("v2values[[", psaIterationNumber,"]] must be a list")
	if (!("probOfNonvisualization" %in% names(v2)))
		stop("v2 must contain probOfNonvisualization (and many other elements)")
	
	# Create and analyze the persons, and return what is needed.
	processPersonsResult <- processPersons(v0, v1other, v2)
	result <- list(meanQuantities=processPersonsResult$meanQuantities, v2=v2)
	if (v0$returnEventHistories) 
		result$eventHistories <- processPersonsResult$eventHistories
	return(result)
}

################################################################################
# generateV2, a function to generate specific values of v2, the global 
# uncertain parameters, from v1distributions, the global fixed parameters that 
# are used for generating elements of v2. 
# The elements of v1distributions can be called hyperparameters.


# generateV2 now works by looking at the "type" attribute of each element of 
# v1distributions. That tells it what distribution to use to generate 
# the corresponding element of v2. The element of v2 is given the same name 
# as the element of v1distributions. If an element of v3 is also generated (as 
# it is for probabilities that are generated from beta distributions), that is 
# also given the same name - so v3$probOfXxxYyy would be a boolean. 

# Probabilities are complicated. If the v1distributions element has type 
# "fixed value for probability" then the same value is assigned to the v2 
# element. If the v1distributions element has type "beta pars for probability" 
# then the v2 element is generated from a beta distribution. If the 
# v1distributions element has type "hyperpars for logistic model for 
# probability" then the v2 element is a logistic model (that is, a vector 
# consisting of beta0, beta1, etc.), and that v2 element is later used to 
# generate a probability and then from that a boolean. 
#  
# In the "fixed value for probability" and "beta pars for probability" cases, 
# the probabilities (specific single numbers) are generated in generateV2 and 
# the boolean/binary variables are generated in processOnePair. 
# 
# For logistic ones, the logistic model (i.e. the set of betas) is generated 
# in generateV2, and the probabilities and boolean variables are generated in 
# generateEventHistory. (generateEventHistory calls getBinaryVariable, which 
# calls calculateProbFromLogisticModel and then rbernoulli.) So v2$probOfXxxYyy 
# is the hyperparameters of the logistic model and v2$probOfXxxYyy is 
# the parameters of the logistic model.


# For rates there are several methods/types. Obviously "gammaThenMultiplyByFour"
# and "betaThenConvertThreeMonthProbToRate" are designed for use with numbers 
# from Table 1 in Kim 2007. 


generateV2 <- function(v1distributions) {
	
	v2 <- compactList()
	
	# Generate specific values of v2, the uncertain global variables.
	# This big loop deals with everything except the aorta model. 
	for (elementName in names(v1distributions)) {
		
		# Get v1element and type. 
		v1element <- v1distributions[[elementName]]
		type <- attr(v1element, "type")
		if (is.null(type)) 
			stop("the \"type\" element of v1distributions$", elementName, 
					" is NULL")
		
		if (type == "fixed value") {
			# These are parameters that will probably be random/uncertain in 
			# the future, but for now are fixed/deterministic.
			v2element <- v1element
			#attr(v2element, "type") <- "fixed value"  # done by previous line
			
		} else if (type == "beta pars for probability") {
			v2element <- myRbeta(n=1, 
					shape1=v1element$alpha, shape2=v1element$beta)
			attr(v2element, "type") <- "probability"
			
		} else if (type == "hyperpars for logistic model for probability") {
			# This type is not just a logistic model but is also allowed to 
			# have logOddsAdjustment. 
			require(MASS, quietly=TRUE)
			if (length(v1element$mean) == 1) {
				v2element <- rnorm(n=1, mean=v1element$mean, 
						sd=sqrt(v1element$variance))
				names(v2element) <- "intercept"
			} else {
				v2element <- mvrnorm(n=1, 
						mu=v1element$mean, Sigma=v1element$covariance)
			}
			if ("logOddsAdjustment" %in% names(v1element))
				v2element <- c(v2element, 
						logOddsAdjustment=v1element$logOddsAdjustment)
			attr(v2element, "type") <- "logistic model for probability"
			
		} else if (type == "gamma pars for rate") {
			v2element <- rgamma(n=1, 
					shape=v1element$shape, scale=v1element$scale)
			attr(v2element, "type") <- "rate"
			
		} else if (type == "gamma pars for multiple rates") {
		  v2element <- rgamma(n=length(v1element$shapes), 
		                      shape=v1element$shapes, scale=v1element$scales)
		  attr(v2element, "type") <- "reintervention rates"
		  # TODO: check the "multiple rates" type of v2, in checkArgs.R
			
		} else if (type == "pars for betaThenConvertThreeMonthProbToRate") {
			v2element <- convertThreeMonthProbToRate(myRbeta(n=1, 
					shape1=v1element$alpha, shape2=v1element$beta))
			attr(v2element, "type") <- "rate"
			
		} else if (type == "pars for gammaThenMultiplyByFour") {
			v2element <- rgamma(n=1, 
					shape=v1element$shape, scale=v1element$scale) * 4
			attr(v2element, "type") <- "rate"
			
		} else if (type == "hyperpars for aorta model") {
			# do nothing; see below
		
		} else if (type == "fixed value for probability") {
			# Copy it and change the type to "probability".
			v2element <- v1element
			attr(v2element, "type") <- "probability"
			# processOnePair will subsequently use v2element as a probability 
			# and generate a boolean from it.
			## Surely this would be quicker than these two lines: 
			## v2element <- setType(v1element, "probability")

		} else if (type == "truncated normal distribution") {
		  v2element <- max(0, min(1, rnorm(n=1, mean=v1element$mean, 
		                     sd=sqrt(v1element$variance)))) 
		  attr(v2element, "type") <- "probability"
		  
		} else if (type == "fixed value for costs") {
			# Copy it and change the type to "costs".
			v2element <- v1element
			attr(v2element, "type") <- "costs"

		} else if (type == "distribution for costs") {
		  v2element <- 
		    vector(mode="numeric", length=length(v1distributions$costs$mean))
		  for (i in 1:length(v1distributions$costs$mean)) {
		    v2element [[i]] <- exp(rnorm(n=1, mean=v1distributions$costs$mean[[i]], 
		                            sd=sqrt(v1distributions$costs$variance)))
		    names(v2element)[[i]]<-names(v1distributions$costs$mean)[[i]]
		  }
		  attr(v2element, "type") <- "costs"
		    
		} else if (type == "fixed value for reintervention rates") {
			# Copy it and change the type to "reintervention rates".
			v2element <- v1element
			attr(v2element, "type") <- "reintervention rates"
			# If/when these rates become uncertain, make a new type, maybe 
			# "random distribution for reintervention rates". 
		
		} else if (type == "fixed value for rate") {
		  # Copy it and change the type to "rate".
		  v2element <- v1element
		  attr(v2element, "type") <- "rate"
		  
		} else if(type == "normal distribution for logit prevalence") {
		  ## Added by MJS 09/03/17 to allow prevalence to be specified by a logistic model
		  v2element <- plogis(rnorm(n=1, mean=v1element$mean, sd=sqrt(v1element$variance)))
	    attr(v2element, "type") <- "probability"
		} else {
			stop("INTERNAL ERROR: checkArgs should have caught this earlier.",
					"\n type=", {if (is.null(type)) "NULL" else type}, 
					" is illegal; elementName=", elementName)
		}
		
		# Check v2element is not NULL or NA and that it has a "type" attribute.
		if (type != "hyperpars for aorta model") {
			if (is.null(v2element) || any(is.na(v2element))) 
				stop("v2element is NULL or contains NAs; elementName=", 
						elementName)
			if (is.null(attr(v2element, "type")))
				stop("the \"type\" element of v2element is NULL; elementName=", 
						elementName)
		}
		
		# Set the v2 element (unless type is "hyperpars for aorta model").
		if (type != "hyperpars for aorta model")
			v2[[elementName]] <- v2element
	}
	
	# Generate the v2 elements that are needed for aortaModel.R, 
	# i.e. deal with type="hyperpars for aorta model". 
	# ("transformed" means atanhRho etc., as opposed to rho etc.)
	require(MASS, quietly=TRUE)
	growthParametersTransformed <- mvrnorm(n=1,	
			mu=v1distributions$meanForGrowthParameters, 
			Sigma=v1distributions$covarianceForGrowthParameters)
	growthParametersUntransformed <- 
			untransformAortaGrowthPars(growthParametersTransformed)
	for (parName in names(growthParametersUntransformed))
		v2[[parName]] <- growthParametersUntransformed[parName]
	# Alternatively, these assignments could have been hard-coded, e.g. 
	#v2$rho <- tanh(growthParametersTransformed["atanhRho"])
	ruptureParameters <- mvrnorm(n=1, 
			mu=v1distributions$meanForRuptureParameters, 
			Sigma=v1distributions$covarianceForRuptureParameters)
	v2$gamma <- ruptureParameters["gamma"]
	v2$alpha <- ruptureParameters["alpha"]
	for (elementName in c("beta0", "beta1", "sigma0", "sigma1", "rho", "sigmaW",
			"gamma", "alpha"))
		attr(v2[[elementName]], "type") <- "par for aorta model"
	
	# If v1other$prevalenceDistribution exists, generate v2$prevalence. 
	if ("prevalenceDistribution" %in% names(v1other))
		stop("code in generateV2 for dealing with ",
				"v1other$prevalenceDistribution \n has not yet been written")
	
	# Example: in the future, if you decide that aaaBbb should be uncertain 
	# rather than fixed, then get rid of v1other$aaaBbb and replace it with 
	# v1distributions$aaaBbb. v1distributions$aaaBbb can have type "fixed value"
	# as a temporary measure. When you decide what probability distribution to 
	# use, make it have some different type and write code in generateV2 to 
	# generate v2$aaaBbb from v1distributions$aaaBbb. 
	# In parsForMen4yearsValidation.R etc., it will be necessary to define 
	# v1distributions$aaaBbb and v2$aaaBbb.

	return(v2)
}

################################################################################

# TODO: (maybe) make psa return the quantities at specified times, to enable 
# the drawing of graphs like Figure 2 in Kim 2007. This would mean setting 
# v0$returnEventHistories to TRUE and doing calculateHealthEconomicQuantities 
# on truncated event-histories. (I think that would be better than changing 
# processOnePair to do calculateHealthEconomicQuantities on a truncated 
# event-history.) Actually these both sound quite fiddly.


